# 什么是微服务
微服务不是发明出来的，是业务需求和技术演进出来的。采用分而治之的方法，在功能上将单体应用分割为更小的原子单位，每个原子单位只实现单一的功能。
与传统N层架构相比，每个微服务有各自的展现层、业务层和数据库层，与业务功能对应或一致，微服务之间是相互隔离的，一个微服务变更不会影响其他微服务
同时，DevOps和云计算也是微服务的两个重要方面

## Martin Fowler给出的定义
微服务架构风格是一种将单个应用开发为一套微小服务的方法。每个这样的微小服务在各自的进程内运行，采用轻量级的机制（通常是http资源API）与外界通信。这些微小服务通常围绕业务能力进行构建，并且可以用完全自动化的部署工具独立部署。微服务架构最起码要实现集中式服务管理，服务本身可能是用不同的编程语言和不同的数据存储技术实现的。
## 微服务架构设计原则
### 单一责任
### 服务自治
- 微服务是自包含且可独立部署的自治服务，负责业务功能及其执行。微服务会捆绑所有依赖，包括第三方依赖、执行环境依赖（比如Web服务器和容器）和抽象了物理资源的虚拟机依赖。
- 微服务和SOA的一个主要区别在于服务的自治程度。虽然大多数SOA实现提供了服务级别的抽象，但微服务进一步抽象了实现和运行环境。
- 传统应用部署中，首先会构建一个或多个war或jar包，部署到JEE应用服务上，而微服务部署是将每个微服务构建为一个包含所有依赖的胖jar，然后在一个独立的Java进程中运行。微服务也可以在自己的容器中运行，容器是跨平台且可独立管理的轻量级运行环境。容器技术（比如Docker）是部署微服务的理想选择。

## 特性
### 服务是一等公民
微服务抽象了实现细节，对外通过API暴露服务端点，提供服务能力。
由于微服务或多或少像SOA，因此SOA中的许多服务特性也适用于微服务
- 服务合约：与SOA类似，微服务也是通过明确定义的服务合约来描述。JSON和REST广泛用于服务之间通信，同时也有很多技术如JSON Schema、WADL、Swagger和RAML等定义服务合约
- 松耦合：各自独立且松耦合的。通常通过消息机制、HTTP等实现服务间交互
- 服务抽象：不仅抽象服务实现的细节，更抽象所有库和环境细节
- 服务复用：微服务是粗粒度、可利用的服务
- 无状态化：无会话状态和共享状态。易于横向扩展和弹性伸缩
- 服务可发现性：服务会自我广播以便于外界发现，服务终结后它们会从微服务体系中自动消失。
- 服务互操作性
- 服务可组合性：服务编排和服务编制


### 微服务是轻量级的
因为设计良好的微服务对应单一业务功能，只实现一个功能，所以要求服务运行所需的资源较少，这也是一个必然要求。
选择微服务的支持技术，必须确保这些技术本身也是轻量级的，以确保服务整体资源开销是可控的。
- 如选择web容器，与传统Weblogic或WebSphere相比，选择Jetty或Tomcat作为微服务的容器更好
- 如与hypervisor技术（如VMware或Hyper-V）相比，容器技术（如Docker）有助于将基础设施的资源开销控制到最小

### 微服务是混合架构
> 本质是因为微服务之间独立不相互影响

- 不同微服务可以采用同一技术的不同版本开发
- 不同微服务可以选择不同的开发语言开发
- 不同微服务可以选择不同的存储架构开发

### 自动化必需性
由于微服务化将原来的单体应用打散为微服务，可能会出现微服务激增的情况，若非实现自动化，微服务将难以管理。
微服务较小的资源开销也有利于其从开发到部署的生命周期自动化
自动化生命周期：
- 自动化持续集成：开发阶段使用版本控制工具（如Git）和**持续集成**工具（如Jenkins、TravisCI等）实现自动化。
- 自动化测试：测试阶段使用自动化测试工具（如Selenium和Cucumber）和其他**A/B测试策略**实现自动化测试
- 自动化基础设施配置：通过容器技术、发布管理工具以及配置管理工具实现
- 自动化部署：可以使用SpringCloud、Kubernetes(k8s)等工具实现

### 生态支持系统
- DevOps流程
- 集中化日志管理
- 服务注册
- API网关
- 大量监控
- 服务路由
- 流量控制机制

### 微服务是动态分布式的
成功的微服务实现在服务中封装了逻辑和数据，这也导致了以下两种不寻常的状况：
- 分布式的数据和逻辑
- 去中心化的服务治理

从单体应用向微服务发展，原单体应用的边界发展为各自微服务创建自己的新的逻辑和数据边界
通常微服务集中式服务治理运行方式与SOA架构的不同，微服务实现的一个共性是不依赖于企业级重量级应用，如企业服务总线（ESB）。严重依赖静态服务注册和静态服务配置会产生额外的开销。这就是大多数微服务采用自动化的机制，利用系统的运行时拓扑来动态构建服务注册信息的原因。

### 抗脆弱、快速失败和自我愈合
**快速失败（fast fail）**是用于构建容错、弹性系统的另一个概念。提倡系统应接纳失败，而不是构建不出错的系统。关于在于一旦出错，系统如何从故障中快速恢复。这种系统设计方式的重心从**平均故障间隔时间（MTBF）**转向为平均恢复时间（MTTR）。关键优势在于某个功能出错，它会结束自身不影响下游功能。
自我愈合通常用于服务的部署中，系统会自动从故障中学习并调整自身，这种自我愈合系统也能避免之后出现错误

### 服务可替换性
微服务是自包含且可独立部署的模块，这使得可以将一个微服务替换为另一个相似的微服务
微服务可以选择购买或自开发，一些功能可以向外部购买实现功能补充。

<br/>

# 相关架构风格和用例
## SOA
SOA是一种支持面向服务的架构风格。面向服务是一种基于服务、服务开发和服务产出来思考问题的方式
### 面向服务的集成
“意大利面条式集成”，通常叫做**面向服务集成（SOI）**。各个服务通过公共集成层进行通信，使用标准协议和消息格式。
### 遗留系统现代化
有些IT转型项目或遗留系统现代化项目中使用SOA，将服务构建和部署在ESB上
### 面向服务的应用
在应用层面使用SOA

## 十二要素应用
基于云计算服务的“云原生”开发，将应用搬到云上，并充分理解和利用云计算特性，如弹性计算、按用量收费和失效感知等。
Heroku提出的十二要素应用是一种方法论，用于描述当代云计算应用应该具备几大特性，这些特性同样适用于微服务
### 单一代码仓库
每个应用应当只有其对应的一个代码仓库，同一代码库可以有多个部署实例，如不同环境的实例，通常用Git等版本控制系统管理代码

### 依赖捆绑
应用应将其应用包与外部依赖捆绑在一起，利用Maven或Gradle等构建工具在项目对象模型（POM）或gradle文件中显式管理第三方依赖，然后利用集中式构建件仓库（如Nexus或Archie）将这些依赖关联起来

### 配置外部化
所以配置信息都应该外部化，同时也有利于自动化部署和发布流程。

### 支撑服务 可寻址
所有支撑服务都应该可以通过可寻址的URL地址访问，而无须复杂的通信

### 构建、发布和运行时的隔离
倡导在构建阶段、发布阶段和运行阶段之间实行强隔离。
- 构建期是指将资源和代码编译和生成为二进制代码
- 发布期是指将二进制代码和环境特定配置参数整合在一起
- 运行期是指在特定运行环境中运行应用程序
该构建管道是意向的，不应为生产环境特定构建，所有构建都应通过构建管道构建出来
### 无状态、不共享进程
### 通过端绑定暴露服务
### 水平扩展实现高并发
### 最小开销实现可外置性
启动和关闭时间应当最小化，并且支持优雅关闭，包体积尽量小，也可以考虑延迟加载对象和数据
### 开发环境和生产环境对等性
### 日志信息外部化
不应该尝试存储和传输日志文件。使用集中式日志框架解决，捕获日志流并发送给集中式日志服务，以便保存和进一步分析
### 打包后台管理进程

